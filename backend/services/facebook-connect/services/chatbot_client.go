package servicesimport (	"bytes"	"encoding/json"	"fmt"	"log"	"net/http"	"facebook-connect/config"	"facebook-connect/models")// ChatBotClient handles communication with the ChatBot servicetype ChatBotClient struct {	config *config.Config	client *http.Client}// NewChatBotClient creates a new ChatBot clientfunc NewChatBotClient(cfg *config.Config) *ChatBotClient {	return &ChatBotClient{		config: cfg,		client: &http.Client{},	}}// ProcessMessage sends a message to the ChatBot service for processingfunc (c *ChatBotClient) ProcessMessage(req *models.ChatBotRequest) (*models.ChatBotResponse, error) {	url := fmt.Sprintf("%s/api/v1/auto-reply", c.config.ChatBotCoreURL)		jsonData, err := json.Marshal(req)	if err != nil {		return nil, fmt.Errorf("failed to marshal ChatBot request: %w", err)	}		log.Printf("ðŸ¤– Sending to ChatBot: %s", string(jsonData))		resp, err := c.client.Post(url, "application/json", bytes.NewBuffer(jsonData))	if err != nil {		return nil, fmt.Errorf("failed to call ChatBot service: %w", err)	}	defer resp.Body.Close()		if resp.StatusCode != http.StatusOK {		return nil, fmt.Errorf("ChatBot service returned status: %d", resp.StatusCode)	}		var chatbotResp models.ChatBotResponse	if err := json.NewDecoder(resp.Body).Decode(&chatbotResp); err != nil {		return nil, fmt.Errorf("failed to decode ChatBot response: %w", err)	}		log.Printf("ðŸ¤– ChatBot response: should_reply=%t, response=%s", chatbotResp.ShouldReply, chatbotResp.Response)	return &chatbotResp, nil}