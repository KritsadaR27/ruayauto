package handler

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"ruaymanagement/backend/internal/ChatBotCore/config"
	"ruaymanagement/backend/internal/ChatBotCore/database"
	"ruaymanagement/backend/internal/ChatBotCore/models"
	"ruaymanagement/backend/internal/ChatBotCore/utils"
	
	"github.com/gin-gonic/gin"
)

type FacebookWebhookPayload struct {
	Object string `json:"object"`
	Entry  []struct {
		ID      string `json:"id"`
		Changes []struct {
			Field string `json:"field"`
			Value struct {
				From struct {
					ID   string `json:"id"`
					Name string `json:"name"`
				} `json:"from"`
				Message   string `json:"message"`
				CommentID string `json:"comment_id"`
				PostID    string `json:"post_id"`
			} `json:"value"`
		} `json:"changes"`
	} `json:"entry"`
}

var (
	defaultResponses = []string{"‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡πÄ‡∏´‡πá‡∏ô‡∏Ñ‡πà‡∏∞"}
	enableDefault    = true
	noTag            = true
	noSticker        = true
)

func FacebookWebhookHandler(c *gin.Context) {
	var payload FacebookWebhookPayload
	if err := c.ShouldBindJSON(&payload); err != nil {
		fmt.Println("‚ùå Error binding JSON:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid payload"})
		return
	}

	fmt.Println("üì© Webhook received")

	// Get database connection
	db := database.GetInstance()
	convRepo := models.NewConversationRepository(db)
	msgRepo := models.NewMessageRepository(db)
	ctx := context.Background()

	for _, entry := range payload.Entry {
		pageID := entry.ID // Facebook page ID
		
		for _, change := range entry.Changes {
			fmt.Printf("üß† Field: %s\n", change.Field)
			text := change.Value.Message
			commentID := change.Value.CommentID
			postID := change.Value.PostID
			userID := change.Value.From.ID
			userName := change.Value.From.Name
			
			fmt.Printf("üó®Ô∏è Message: %s | üí¨ CommentID: %s | üë§ User: %s\n", text, commentID, userName)

			// Get or create conversation
			conv, err := convRepo.GetOrCreate(ctx, pageID, userID, "comment", &postID)
			if err != nil {
				fmt.Printf("‚ùå Failed to get/create conversation: %v\n", err)
				continue
			}

			// Update user name if provided
			if userName != "" && conv.FacebookUserName == nil {
				conv.FacebookUserName = &userName
			}

			// Store incoming message
			startTime := time.Now()
			incomingMsg := &models.Message{
				ConversationID: conv.ID,
				MessageID:      &commentID,
				SenderType:     "user",
				Content:        &text,
				MessageType:    "text",
				Metadata:       "{}",
			}
			
			if err := msgRepo.Create(ctx, incomingMsg); err != nil {
				fmt.Printf("‚ùå Failed to store incoming message: %v\n", err)
			}

			// ‡πÄ‡∏ä‡πá‡∏Ñ noTag
			if noTag && strings.Contains(text, "@") {
				fmt.Println("üö´ ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏ó‡πá‡∏Å")
				continue
			}

			var replyText string
			var matched bool

			// Try to match keyword
			if reply, ok := utils.MatchKeyword(text); ok {
				replyText = reply
				matched = true
			} else if enableDefault && len(defaultResponses) > 0 {
				// ‡∏ï‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö default
				replyText = utils.GetRandomDefaultResponse()
				matched = true
			}

			if matched && replyText != "" {
				cfg := config.Get()
				err := utils.PostCommentReply(commentID, replyText, cfg.GetFacebookPageToken())
				
				// Calculate response time
				responseTime := int(time.Since(startTime).Milliseconds())
				
				if err != nil {
					fmt.Printf("‚ö†Ô∏è Failed to reply: %v\n", err)
				} else {
					fmt.Println("‚úÖ Replied to comment!")
					
					// Store bot response
					botMsg := &models.Message{
						ConversationID: conv.ID,
						SenderType:     "bot",
						Content:        &replyText,
						MessageType:    "text",
						Metadata:       "{}",
						ResponseTimeMs: &responseTime,
					}
					
					if err := msgRepo.Create(ctx, botMsg); err != nil {
						fmt.Printf("‚ùå Failed to store bot message: %v\n", err)
					}
					
					// Mark incoming message as processed
					if err := msgRepo.MarkAsProcessed(ctx, incomingMsg.ID, responseTime); err != nil {
						fmt.Printf("‚ùå Failed to mark message as processed: %v\n", err)
					}
				}
				
				// Update conversation last message time
				if err := convRepo.UpdateLastMessageAt(ctx, conv.ID); err != nil {
					fmt.Printf("‚ùå Failed to update conversation: %v\n", err)
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{"status": "received"})
}

func FacebookVerifyHandler(c *gin.Context) {
	cfg := config.Get()
	verifyToken := cfg.GetFacebookVerifyToken()
	mode := c.Query("hub.mode")
	token := c.Query("hub.verify_token")
	challenge := c.Query("hub.challenge")

	if mode == "subscribe" && token == verifyToken {
		fmt.Printf("‚úÖ Facebook webhook verification successful for token: %s\n", token[:8]+"...")
		c.String(http.StatusOK, challenge)
	} else {
		fmt.Printf("‚ùå Facebook webhook verification failed. Mode: %s, Token: %s\n", mode, token)
		c.String(http.StatusForbidden, "Verification failed")
	}
}

func GetKeywordsHandler(c *gin.Context) {
	pairs := utils.GetAllKeywordPairs()
	c.JSON(http.StatusOK, gin.H{
		"pairs":            pairs,
		"defaultResponses": defaultResponses,
		"enableDefault":    enableDefault,
		"noTag":            noTag,
		"noSticker":        noSticker,
	})
}

func SaveKeywordsHandler(c *gin.Context) {
	var req struct {
		Pairs []struct {
			Keywords  []string `json:"keywords"`
			Responses []string `json:"responses"`
		} `json:"pairs"`
		DefaultResponses []string `json:"defaultResponses"`
		EnableDefault    bool     `json:"enableDefault"`
		NoTag            bool     `json:"noTag"`
		NoSticker        bool     `json:"noSticker"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid data format"})
		return
	}
	utils.SetKeywordPairsV2(req.Pairs)
	defaultResponses = req.DefaultResponses
	enableDefault = req.EnableDefault
	noTag = req.NoTag
	noSticker = req.NoSticker
	c.JSON(http.StatusOK, gin.H{"ok": true})
}
